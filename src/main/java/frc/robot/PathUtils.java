/*----------------------------------------------------------------------------*/
/* Copyright (c) 2018-2019 FIRST. All Rights Reserved. */
/* Open Source Software - may be modified and shared by FRC teams. The code */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project. */
/*----------------------------------------------------------------------------*/

package frc.robot;

import java.io.IOException;
import java.nio.file.Path;
import java.util.List;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Translation2d;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryConfig;
import edu.wpi.first.wpilibj.trajectory.TrajectoryGenerator;
import edu.wpi.first.wpilibj.trajectory.TrajectoryUtil;
import edu.wpi.first.wpilibj.trajectory.constraint.DifferentialDriveVoltageConstraint;
import edu.wpi.first.wpilibj2.command.RamseteCommand;
import frc.robot.subsystems.driveSubsystem;
import static frc.robot.Constants.AutoConstants.kMaxAccelerationMetersPerSecondSquared;
import static frc.robot.Constants.AutoConstants.kMaxSpeedMetersPerSecond;
import static frc.robot.Constants.AutoConstants.kRamseteB;
import static frc.robot.Constants.AutoConstants.kRamseteZeta;
import static frc.robot.Constants.driveConstants.kDriveKinematics;

/**
 * PathWeaver places JSON files in src/main/deploy/paths which will automatically be placed on the
 * roboRIO file system in /home/lvuser/deploy/paths and can be accessed using getDeployDirectory as
 * shown below.
 */

/**
 * PahtUtils - utilities for importing paths generated by PathWeaver and creating Ramsete Commands.
 */
public class PathUtils {

    /**
     * Open PathWeaver file and return the trajectory. Return NULL if file open fails.
     * 
     * @param filename
     * @return trajectory or null on failure
     */
    public Trajectory loadPathWeaverTrajectory(String filename) {

        String trajectoryJSON = "paths/" + filename;
        try {
            Path trajectoryPath = Filesystem.getDeployDirectory().toPath().resolve(trajectoryJSON);
            Trajectory trajectory = TrajectoryUtil.fromPathweaverJson(trajectoryPath);
            return trajectory;
        } catch (IOException ex) {
            DriverStation.reportError("Unable to open trajectory: " + trajectoryJSON,
                    ex.getStackTrace());
        }
        return null;
    }

    /**
     * isReversed - return true if the path is driven in reverse. Looks for the sub-string REVERSE
     * in the filename.
     * 
     * @param filename
     * @return boolean
     */
    public boolean isReversed(String filename) {
        if (filename.contains("REVERSE")) {
            return true;
        }
        return false;
    }
    
    /**
     * 
     * Create 
     * 
     * @param drive
     * @param startPose
     * @param translationList
     * @param endPose
     * @return
     */
    public RamseteCommand createTrajectoryCommand(driveSubsystem m_drive,
            Pose2d startPose, List<Translation2d> translationList, Pose2d endPose) {
        DifferentialDriveVoltageConstraint autoVoltageConstraint;
        TrajectoryConfig config;
   
        // Create a voltage constraint to ensure we don't accelerate too fast
        autoVoltageConstraint = new DifferentialDriveVoltageConstraint(m_drive.getFeedforward(), kDriveKinematics, 6);
    
        // Create config for trajectory
        config = new TrajectoryConfig(kMaxSpeedMetersPerSecond, kMaxAccelerationMetersPerSecondSquared)
            // Add kinematics to ensure max speed is actually obeyed
            .setKinematics(kDriveKinematics)
            // Apply the voltage constraint
            .addConstraint(autoVoltageConstraint);
    
        var initalTime = System.nanoTime();
    
        // trajectory to follow. All units in meters.
        var trajectory = TrajectoryGenerator.generateTrajectory(
            startPose,
            translationList,
            endPose,
            config);
    
        RamseteCommand ramseteCommand =
            new RamseteCommand(trajectory, 
                m_drive::getPose,
                new RamseteController(kRamseteB, kRamseteZeta),
                m_drive.getFeedforward(),
                kDriveKinematics,
                m_drive::getWheelSpeeds,
                m_drive.getLeftPidController(),
                m_drive.getRightPidController(),
                m_drive::tankDriveVolts,
                m_drive);
    
        var dt = (System.nanoTime() - initalTime) / 1E6;
        System.out.println("RamseteCommand generation time: " + dt + "ms");
    
        // Run path following command, then stop at the end.
        return ramseteCommand;
      }

}

